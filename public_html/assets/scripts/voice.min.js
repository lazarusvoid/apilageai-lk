 const micButton = document.getElementById('voicebox-micButton');
        const lightbox = document.getElementById('voicebox');
        const closeButton = document.getElementById('voicebox-closeButton');
        const conversationMicButton = document.getElementById('voicebox-conversationMicButton');
        const statusText = document.getElementById('voicebox-statusText');
        const voiceSelect = document.getElementById('voicebox-voiceSelect');
        const userTranscriptEl = document.getElementById('voicebox-user-transcript');
        const aiResponseEl = document.getElementById('voicebox-ai-response');

        // --- State and API ---
        let isListening = false;
        let selectedVoice = null;
        const chatHistory = [
            { role: "user", parts: [{ text: "Please respond only in the Sinhala language from now on." }] },
            { role: "model", parts: [{ text: "හොඳයි, මම දැන් සිට සිංහලෙන් පමණක් පිළිතුරු දෙන්නම්." }] }
        ];
        const apiKey = "AIzaSyAJLaX4BksgYBxMJXpsUp0mkTgwnDw7SRA"; // Leave empty, will be handled by the environment

        // --- Web Speech API for Recognition ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'si-LK';
            recognition.interimResults = false;
        } else {
            console.error("Speech Recognition not supported in this browser.");
            statusText.textContent = "Speech Recognition not supported in this browser.";
        }

        // --- Helper Functions ---
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Correctly write 16-bit PCM data
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        const audioQueue = {
            queue: [],
            isPlaying: false,
            add(audioBlob) {
                this.queue.push(audioBlob);
                if (!this.isPlaying) {
                    this.playNext();
                }
            },
            playNext() {
                if (this.queue.length === 0) {
                    this.isPlaying = false;
                    updateStatus('සූදානම්. කතා කිරීමට මයික්‍රෆෝනය ක්ලික් කරන්න.', false);
                    conversationMicButton.disabled = false;
                    return;
                }
                this.isPlaying = true;
                const audioBlob = this.queue.shift();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.play();
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    this.playNext();
                };
                 audio.onerror = (e) => {
                    console.error("Error playing audio:", e);
                    URL.revokeObjectURL(audioUrl);
                    this.playNext(); // Try the next item in the queue
                };
            }
        };

        // --- UI Update Functions ---
        function updateStatus(text, isPulsing) {
            statusText.textContent = text;
            if (isPulsing) {
                conversationMicButton.classList.add('listening');
            } else {
                conversationMicButton.classList.remove('listening');
            }
        }

        function openLightbox() {
            lightbox.style.display = 'flex';
            setTimeout(() => {
                lightbox.classList.add('visible');
            }, 10);
        }

        function closeLightbox() {
            lightbox.classList.remove('visible');
            setTimeout(() => {
                lightbox.style.display = 'none';
                if (isListening) {
                    recognition.stop();
                }
            }, 300);
        }

        // --- API Call Functions ---
        async function fetchWithBackoff(url, payload, maxRetries = 3) {
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.status === 401 || response.status === 403) {
                         throw new Error(`Authentication error! Please check your API key. Status: ${response.status}`);
                    }
                    if (response.status === 429) {
                        throw new Error(`Rate limit exceeded. Status: ${response.status}`);
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    // Non-retryable error
                    if (error.message.includes('Authentication error')) {
                        throw error;
                    }
                    attempt++;
                    if (attempt >= maxRetries) {
                        console.error(`API call failed after ${maxRetries} attempts:`, error);
                        throw error;
                    }
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    console.log(`Rate limit hit. Retrying in ${Math.round(delay/1000)}s...`);
                    updateStatus(`API කාර්යබහුලයි. තත්පර ${Math.round(delay/1000)}කින් නැවත උත්සාහ කරමින්...`, false);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function getAiTextResponse(prompt) {
            updateStatus('සිතමින්...', false);
            const payload = { contents: chatHistory };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            try {
                const result = await fetchWithBackoff(apiUrl, payload);
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "සමාවන්න, මට පිළිතුරක් සිතාගත නොහැකි විය.";
                chatHistory.push({ role: "model", parts: [{ text: text }] });
                return text;
            } catch (error) {
                console.error("API call failed:", error);
                updateStatus('දෝෂයක්. කරුණාකර නැවත උත්සාහ කරන්න.', false);
                return "මට දෝෂයක් ඇතිවිය. ඔබට එය නැවත කිව හැකිද?";
            }
        }

        async function streamAndPlayResponse(fullText) {
            aiResponseEl.textContent = `සහායක: ${fullText}`;
            updateStatus('හඬ නිර්මාණය කරමින්...', false);
            conversationMicButton.disabled = true;

            const payload = {
                contents: [{ parts: [{ text: fullText }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: selectedVoice || "Kore" }
                        }
                    }
                }
            };

            const model = "gemini-2.5-flash-preview-tts";
            const api = "generateContent";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:${api}?key=${apiKey}`;

            try {
                const result = await fetchWithBackoff(apiUrl, payload);
                updateStatus('කතා කරමින්...', false);
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const audioBlob = pcmToWav(pcm16, sampleRate);
                    audioQueue.add(audioBlob);
                } else {
                    throw new Error("No audio data received from API.");
                }
            } catch (error) {
                console.error("Error generating audio:", error);
                updateStatus('හඬ නිර්මාණයේ දෝෂයකි.', false);
                aiResponseEl.textContent += "\n(සමාවන්න, මෙම පිළිතුර සඳහා හඬ නිර්මාණය කිරීමට නොහැකි විය.)";
                conversationMicButton.disabled = false;
            }
        }

        // --- Event Handlers ---
        function handleMicClick() {
            if (!recognition) return;
            if (isListening) {
                recognition.stop();
                return;
            }
            userTranscriptEl.textContent = '';
            aiResponseEl.textContent = '';
            try {
                recognition.start();
            } catch(e) {
                console.error("Error starting recognition:", e);
                updateStatus("මයික්‍රෆෝන දෝෂයකි. කරුණාකර අවසර පරීක්ෂා කරන්න.", false);
            }
        }

        if (micButton) {
            micButton.addEventListener('click', openLightbox);
        }

        if (closeButton) {
            closeButton.addEventListener('click', closeLightbox);
        }

        if (lightbox) {
            lightbox.addEventListener('click', (e) => {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            });
        }

        if (conversationMicButton) {
            conversationMicButton.addEventListener('click', handleMicClick);
        }

        if (recognition) {
            recognition.onstart = () => {
                isListening = true;
                updateStatus('සවන් දෙමින්...', true);
                conversationMicButton.disabled = true;
            };
            recognition.onend = () => {
                isListening = false;
                updateStatus('සකසමින්...', false);
                // We re-enable the button after the audio queue is finished.
            };
            recognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                let errorMessage = 'දෝෂයක් ඇතිවිය. නැවත උත්සාහ කරන්න.';
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    errorMessage = 'මයික්‍රෆෝන ප්‍රවේශය ප්‍රතික්ෂේප විය. කරුණාකර ඔබේ බ්‍රවුසර සැකසුම් තුළ එයට ඉඩ දෙන්න.';
                } else if (event.error === 'no-speech') {
                    errorMessage = "මට කිසිවක් ඇසුණේ නැත. නැවත උත්සාහ කිරීමට මයික්‍රෆෝනය ක්ලික් කරන්න.";
                }
                updateStatus(errorMessage, false);
            };
            recognition.onresult = async (event) => {
                const transcript = event.results[0][0].transcript;
                userTranscriptEl.textContent = `ඔබ: ${transcript}`;
                chatHistory.push({ role: "user", parts: [{ text: transcript }] });
                const aiText = await getAiTextResponse(transcript);
                await streamAndPlayResponse(aiText);
            };
        }

        // --- Initialization ---
        function populateVoiceList() {
             const voices = [
                { name: "Kore (Firm)", value: "Kore" }, { name: "Puck (Upbeat)", value: "Puck" },
                { name: "Zephyr (Bright)", value: "Zephyr" }, { name: "Charon (Informative)", value: "Charon" },
                { name: "Fenrir (Excitable)", value: "Fenrir" }, { name: "Leda (Youthful)", value: "Leda" },
                { name: "Orus (Firm)", value: "Orus" }, { name: "Aoede (Breezy)", value: "Aoede" },
                { name: "Enceladus (Breathy)", value: "Enceladus" }, { name: "Iapetus (Clear)", value: "Iapetus" },
                { name: "Umbriel (Easy-going)", value: "Umbriel" }, { name: "Algenib (Gravelly)", value: "Algenib" },
            ];
            voiceSelect.innerHTML = '';
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = voice.name;
                option.value = voice.value;
                voiceSelect.appendChild(option);
            });
            selectedVoice = voiceSelect.value;
        }
        
        voiceSelect.addEventListener('change', (e) => {
            selectedVoice = e.target.value;
        });

        populateVoiceList();