document.addEventListener('DOMContentLoaded', function () {
    const url = window.location.href;
    const hamburger = document.querySelector('.hamburger');
    const sidebar = document.getElementById('sidebar');
    const sidebarOverlay = document.querySelector('.sidebar-overlay');
    const sidebarBack = document.getElementById('sidebarback');
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    const navbar = document.querySelector('.navbar');
    const chatContainer = document.getElementById('messages-container');
    const fileAttach = document.getElementById('fileAttach');
    const fileInput = document.getElementById('fileInput');

    const match = url.match(/(\d+)(?!.*\d)/);
    const conversationId = match ? match[1] : null;

    if (conversationId) {
        update_chat();
    }

    // Check screen size and set initial state
    function checkScreenSize() {
        if (window.innerWidth <= 955) {
            // Mobile view - sidebar hidden by default
            sidebar.classList.add('hidden');
            sidebarBack.style.display = 'block';
            navbar.style.display = 'flex'; // Ensure navbar is visible initially
        } else {
            // Desktop view - sidebar visible by default
            sidebar.classList.remove('hidden');
            sidebarBack.style.display = 'none';
            navbar.style.display = 'flex'; // Ensure navbar is visible
        }
    }

    // Run on load and on resize
    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);

    // Toggle sidebar on hamburger click (mobile)
    hamburger.addEventListener('click', function () {
        this.classList.toggle('active');
        sidebar.classList.toggle('hidden');
        sidebarOverlay.classList.toggle('visible');

        // Toggle navbar visibility when sidebar is shown/hidden on mobile
        if (window.innerWidth <= 955) {
            if (sidebar.classList.contains('hidden')) {
                navbar.style.display = 'flex';
                sidebarBack.style.display = 'block';
            } else {
                navbar.style.display = 'none';
                sidebarBack.style.display = 'none';
            }
        }
    });

    // Close sidebar when clicking on overlay (mobile)
    sidebarOverlay.addEventListener('click', function () {
        hamburger.classList.remove('active');
        sidebar.classList.add('hidden');
        this.classList.remove('visible');
        navbar.style.display = 'flex'; // Show navbar when closing sidebar
        sidebarBack.style.display = 'block';
    });

    // Desktop sidebar toggle
    toggleSidebarBtn.addEventListener('click', function () {
        sidebar.classList.add('hidden');
        if (window.innerWidth <= 955) {
            sidebarOverlay.classList.remove('visible');
            navbar.style.display = 'flex'; // Show navbar when closing sidebar on mobile
            sidebarBack.style.display = 'block';
        } else {
            sidebarBack.style.display = 'block';
        }
    });

    // Sidebar back button
    sidebarBack.addEventListener('click', function () {
        sidebar.classList.remove('hidden');
        if (window.innerWidth <= 955) {
            sidebarOverlay.classList.add('visible');
            navbar.style.display = 'none'; // Hide navbar when opening sidebar on mobile
        }
        this.style.display = 'none';
    });

    setGreeting();

    // Handle chat form submission
    const chatForm = document.getElementById('chat-form');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const suggestionsDropdown = document.getElementById('suggestions-dropdown');

    const suggestions = [
        "Look at the image",
        "Search the web (Sri Lankan based)",
        "Draw the graph of",
        "Answer In සිංහල"
    ];

    messageInput.addEventListener('input', function () {
        const cursorPos = this.selectionStart;
        const textBeforeCursor = this.value.slice(0, cursorPos);
        const lastAtIndex = textBeforeCursor.lastIndexOf('@');

        if (lastAtIndex !== -1 && (cursorPos === lastAtIndex + 1 || textBeforeCursor.endsWith('@'))) {
            showSuggestions();
        } else {
            suggestionsDropdown.style.display = "none";
        }

        function showSuggestions() {
            suggestionsDropdown.innerHTML = '';
            suggestions.forEach(item => {
                const div = document.createElement('div');
                div.textContent = item;
                div.classList.add('ghost-style'); // Apply ghost-style here
                div.onclick = () => insertSuggestion(item);
                suggestionsDropdown.appendChild(div);
            });

            const inputRect = messageInput.getBoundingClientRect();
            const formRect = chatForm.getBoundingClientRect();

            // Position dropdown above textarea
            suggestionsDropdown.style.display = "block";
            suggestionsDropdown.style.left = `${inputRect.left - formRect.left}px`;
            suggestionsDropdown.style.top = `${inputRect.top - formRect.top - suggestionsDropdown.offsetHeight - 10}px`;
        }

        function insertSuggestion(text) {
            const cursorPos = messageInput.selectionStart;
            const value = messageInput.value;
            const atIndex = value.lastIndexOf('@', cursorPos);

            const before = value.substring(0, atIndex);
            const after = value.substring(cursorPos);

            const insertedText = text + " ; ";

            messageInput.value = before + insertedText + after;

            // Place cursor after the inserted suggestion
            const newPos = (before + insertedText).length;
            messageInput.focus();
            messageInput.setSelectionRange(newPos, newPos);

            suggestionsDropdown.style.display = "none";
        }

    });

    const charCountDisplay = document.getElementById('char-count');

    messageInput.addEventListener('beforeinput', function (e) {
        const currentLength = this.value.length;

        // Allow deletion and paste
        const allowedInputTypes = [
            'deleteContentBackward',
            'deleteContentForward',
            'insertFromPaste'
        ];

        // Predict next input length
        const inputData = e.data || '';
        const selectionLength = this.selectionEnd - this.selectionStart;
        const predictedLength = currentLength - selectionLength + inputData.length;

        if (predictedLength > 1000 && !allowedInputTypes.includes(e.inputType)) {
            e.preventDefault(); // block extra input
        }
    });

    messageInput.addEventListener('input', function () {
        let currentLength = this.value.length;

        // Trim if user pastes a lot
        if (currentLength > 1000) {
            this.value = this.value.slice(0, 1000);
            currentLength = 1000;
        }

        // Update live character count
        charCountDisplay.textContent = `${currentLength} / 1000 `;

        // Style change at limit
        charCountDisplay.classList.toggle('limit-reached', currentLength >= 1000);

        // Toggle send button
        const hasText = this.value.trim().length > 0;
        sendButton.disabled = !hasText;
        sendButton.classList.toggle('text-muted', !hasText);
        sendButton.classList.toggle('text-primary', hasText);
    });

    messageInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    const previewWrapper = document.querySelector('.preview-wrapper');
    const imagePreview = document.getElementById('imagePreview');
    const removeBtn = document.getElementById('removeImage');
    fileInput.addEventListener('change', function (event) {
        const file = event.target.files[0];

        if (file && file.type.match('image.*')) {
            const reader = new FileReader();

            reader.onload = function (e) {
                imagePreview.src = e.target.result;
                previewWrapper.style.display = 'block';
            }

            reader.readAsDataURL(file);
        }
    });

    removeBtn.addEventListener('click', function () {
        clearAttachments();
    });

    function clearAttachments() {
        fileInput.value = '';
        imagePreview.src = '#';
        previewWrapper.style.display = 'none';
    }

    async function sendMessage() {
        const message = messageInput.value.trim();

        if (!message) return;

        // Show loading image and disable input
        const originalValue = messageInput.value;
        const loadingImage = 'https://apilageai.lk/assets/images/buffer.gif';
        messageInput.disabled = true;
        typingSound.play().catch(() => {}); // play with fallback
        messageInput.value = '';
        messageInput.style.background = `url(${loadingImage}) no-repeat center`;
        messageInput.style.backgroundSize = 'contain';

        // Typing stages animation
        const typingStages = ['Typing', 'Thinking', 'Analysing', 'Searching web'];
        let stageIndex = 0;
        let dotCount = 0;
        let stageInterval;

        const typingTimeout = setTimeout(() => {
            messageInput.style.background = '';
            stageInterval = setInterval(() => {
                dotCount = (dotCount + 1) % 4;
                messageInput.value = typingStages[stageIndex] + '.'.repeat(dotCount);
                if (dotCount === 0) {
                    stageIndex = (stageIndex + 1) % typingStages.length;
                    if (stageIndex === 0) {
                        clearInterval(stageInterval);
                        messageInput.value = '';
                        messageInput.style.background = `url(${loadingImage}) no-repeat center`;
                        messageInput.style.backgroundSize = 'contain';
                    }
                }
            }, 600);
        }, 3000);

        sendButton.disabled = true;
        sendButton.classList.add('text-muted');
        sendButton.classList.remove('text-dark');

        const data = new FormData();
        data.append("m", message);
        data.append("f", fileInput.files[0]);

        if (!conversationId) {
            try {
                const title = await generateTitleWithGemini(message);
                if (title) {
                    data.append("t", title);
                } else {
                    console.warn("Failed to generate title.");
                    // Clean up UI before return
                    clearTimeout(typingTimeout);
                    clearInterval(stageInterval);
                    typingSound.pause();
                    typingSound.currentTime = 0;
                    messageInput.disabled = false;
                    messageInput.style.background = '';
                    messageInput.value = '';
                    return;
                }
            } catch (error) {
                console.error("Error generating title:", error);
                clearTimeout(typingTimeout);
                clearInterval(stageInterval);
                typingSound.pause();
                typingSound.currentTime = 0;
                messageInput.disabled = false;
                messageInput.style.background = '';
                messageInput.value = '';
                return;
            }
        } else {
            data.append("i", conversationId);
        }

        fetch('https://apilageai.lk/api/chat/new', {
            method: 'POST',
            body: data,
            headers: {
                'Accept-Charset': 'utf-8'
            }
        })
            .then(response => response.json())
            .then(data => {
                // Clean up UI loading states
                clearTimeout(typingTimeout);
                clearInterval(stageInterval);
                typingSound.pause();
                typingSound.currentTime = 0;
                messageInput.disabled = false;
                messageInput.style.background = '';
                messageInput.value = '';
                if (data.e) {
                    new Dialog('Error', data.m, {
                        text: 'Okay', action: () => { }, color: '#ff3333'
                    });
                } else {
                    messageInput.value = '';
                    clearAttachments();
                    if (conversationId === data.c_id) {
                        update_chat();
                    } else {
                        window.location.href = `https://apilageai.lk/app/chat/${data.c_id}`;
                    }
                }
            })
            .catch(() => {
                // Clean up UI loading states
                clearTimeout(typingTimeout);
                clearInterval(stageInterval);
                typingSound.pause();
                typingSound.currentTime = 0;
                messageInput.disabled = false;
                messageInput.style.background = '';
                messageInput.value = '';
                new Dialog('Error', 'Something went wrong', {
                    text: 'Okay', action: () => { }, color: '#ff3333'
                });
            });
    }

    sendButton.addEventListener('click', function (event) {
        event.preventDefault();
        sendMessage();
    });

    // Make chat cards clickable
    const chatCards = document.querySelectorAll('.chat-card');

    chatCards.forEach(card => {
        card.addEventListener('click', function () {
            const cardTitle = this.querySelector('.card-title').textContent;
            messageInput.value = cardTitle;
            messageInput.focus();

            // Trigger input event to enable send button
            const inputEvent = new Event('input', { bubbles: true });
            messageInput.dispatchEvent(inputEvent);
        });
    });

    // Auto-resize textarea
    messageInput.addEventListener('input', function () {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    // Handle Enter key for submission
    messageInput.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            chatForm.dispatchEvent(new Event('submit'));
        }
    });

    async function update_chat() {
    const data = new FormData();
    data.append("i", conversationId);
    if (conversationId) {
        const messageIds = [...chatContainer.querySelectorAll('.chatBubble')].map(e => e.dataset.mId);
        if (messageIds.length > 0) {
            data.append("m_ids", messageIds);
        }
    }

    await fetch('https://apilageai.lk/api/chat/get', {
        method: 'POST',
        body: data
    })
        .then(response => response.json())
        .then(data => {
            if (data.e) {
                new Dialog('Error', data.m, {
                    text: 'Okay',
                    action: () => { },
                    color: '#ff3333'
                });
            } else {
                data.m.forEach(item => {
                    let text = item.txt;

                    // Desmos formulas: %%math%%
                    text = text.replace(/%%(.*?)%%/g, (_, fn) => {
                        const trimmedFunction = fn.trim();
                        setTimeout(() => {
                            const rightSidebar = document.getElementById('rightSidebar');
                            const appContainer = document.querySelector('.app-container');
                            if (rightSidebar && !rightSidebar.classList.contains('active')) {
                                rightSidebar.classList.add('active');
                                appContainer?.classList.add('right-sidebar-active');
                            }
                            const graphFunctionInput = document.getElementById('graphFunctionInput');
                            const graphFunctionSubmit = document.getElementById('graphFunctionSubmit');
                            if (graphFunctionInput && graphFunctionSubmit) {
                                graphFunctionInput.value = trimmedFunction;
                                setTimeout(() => {
                                    graphFunctionSubmit.click();
                                    if (window.calculator) {
                                        const functionId = 'func' + Date.now();
                                        window.calculator.setExpression({
                                            id: functionId,
                                            latex: trimmedFunction,
                                            color: Desmos.Colors.BLUE
                                        });
                                    }
                                }, 600);
                            }
                        }, 500);
                        return `<span class="graph-function-highlight" data-function="${trimmedFunction}">
          <span class="badge" onclick="openGraphSidebar('${trimmedFunction}')">➕ Open Graph View</span>
      </span>`;
                    });

                    // Ensure MathJax reads proper delimiters
                    text = text.replace(/\\\((.+?)\\\)/g, (_, expr) => `$${expr}$`);
                    text = text.replace(/\\\[(.+?)\\\]/gs, (_, expr) => `$$${expr}$$`);

                    // Use Marked.js for markdown parsing
                    text = marked.parse(text);
                    // Fix MathJax rendering
                    setTimeout(() => {
                        if (window.MathJax?.typesetPromise) {
                            MathJax.typesetPromise().catch(err => console.warn("MathJax typeset failed", err));
                        }
                    }, 150);
                    // Use PrismJS to highlight code
                    setTimeout(() => {
                        document.querySelectorAll('pre code').forEach((block) => {
                            Prism.highlightElement(block);
                            const pre = block.parentElement;
                            if (!pre.classList.contains("code-container")) {
                                pre.classList.add("code-container");
                                pre.classList.add("line-numbers");
                                const lang = block.className.match(/language-([\w-]+)/)?.[1] || 'text';
                                const header = document.createElement("div");
                                header.className = "code-header";
                                header.innerHTML = `<span class="lang-label">${lang}</span><button class="copy-code-btn">Copy</button>`;
                                pre.insertBefore(header, block);
                            }
                        });
                    }, 100);


                    const chatBubble = document.createElement("div");
                    chatBubble.classList.add("message", item.t == 1 ? "user-message" : "bot-message", "chatBubble");
                    chatBubble.dataset.mId = item.m_id;
                    chatBubble.innerHTML = `
<p>${text}</p>
<div class="message-icons">
    ${item.t != 1 ? `
    <a href="#" class="report-bug-link">
        <button style="background: none; border: none; padding-left: 10px; padding-right: 20px; cursor: pointer;">
            <i class="fa fa-exclamation-triangle" aria-hidden="true" style="color: #8B0000;"></i>
        </button>
    </a>
    <button class="message-thumbs-down icon-button" data-message-id="${item.m_id}">
        <i class="fa fa-refresh"></i>
    </button>
    <button class="message-note icon-button blink-button" data-message="${encodeURIComponent(text)}">
        <i class="fa fa-book"></i>
    </button>
    <button class="message-read-aloud icon-button">
        <i class="fa fa-volume-up"></i>
    </button>` : ``}
    <button class="message-copy icon-button">
        <i class="fa-solid fa-copy"></i>
    </button>
    ${item.t == 1 ? `
    <button class="message-edit icon-button">
        <i class="fa-solid fa-edit"></i>
    </button>` : ``}
</div>

`;

             if (item.t == 1) {
    const editBtn = chatBubble.querySelector('.message-edit');
    if (editBtn) {
        editBtn.addEventListener('click', () => {
            const inputBox = document.getElementById('input');
            if (inputBox) {
                inputBox.value = item.txt.trim();  // Use original raw text
                inputBox.focus();
            }
        });
    }
}

                        // Re genrate 
                        const thumbsDownButton = chatBubble.querySelector('.message-thumbs-down');
                        if (thumbsDownButton) {
                            thumbsDownButton.addEventListener('click', async () => {
                                const mId = thumbsDownButton.dataset.messageId;
                                if (!mId) return;

                                try {
                                    // Send a request to regenerate the message using the same conversation ID and message ID
                                    const formData = new FormData();
                                    formData.append("i", conversationId);
                                    formData.append("m_id", mId); // or use as needed in your backend

                                    const response = await fetch("https://apilageai.lk/api/chat/get", {
                                        method: "POST",
                                        body: formData
                                    });

                                    const result = await response.json();

                                    if (result.e) {
                                        new Dialog("Error", result.m, { text: "OK", color: "#cc0000" });
                                    } else {
                                        // Remove the old message from DOM
                                        chatBubble.remove();

                                        // Re-call your message handler (like update_chat()) to refresh
                                        update_chat(); // assuming this reloads from server
                                    }
                                } catch (error) {
                                    new Dialog("Error", "Failed to regenerate: " + error, {
                                        text: "OK", color: "#cc0000"
                                    });
                                }
                            });
                        }

                        const reportBugLinks = chatBubble.querySelectorAll('.report-bug-link');

                        reportBugLinks.forEach(link => {
                            link.addEventListener('click', function (e) {
                                e.preventDefault();

                                // Open the bug report modal here
                                const modal = document.getElementById("bugReportModal");
                                const form = document.getElementById("bugReportForm");
                                const successMessage = document.getElementById("successMessage");
                                const imagePreview = document.getElementById("imagePreview");

                                // Make sure the modal and form elements are loaded
                                if (modal && form && successMessage) {
                                    modal.style.display = "block";
                                    form.style.display = "block";
                                    successMessage.style.display = "none";
                                    form.reset();
                                    if (imagePreview) imagePreview.style.display = "none";

                                    // Clear any errors if applicable
                                    if (typeof clearErrors === "function") clearErrors();
                                } else {
                                    console.error("Bug report modal elements not found.");
                                }
                            });
                        });

                        // Insert in the correct order based on m_id
                        const nextBubble = Array.from(chatContainer.children).find(child =>
                            parseInt(child.dataset.mId, 10) > item.m_id
                        );

                        if (nextBubble) {
                            chatContainer.insertBefore(chatBubble, nextBubble);
                        } else {
                            chatContainer.appendChild(chatBubble);
                        }
                    });
                }
            })
            .catch((e) => {
                new Dialog(
                    'Error',
                    'Something went wrong' + e,
                    { text: 'Okay', action: () => { }, color: '#ff3333' }
                );
            });

        // Scroll to the bottom after new messages are appended
        chatContainer.scrollTop = chatContainer.scrollHeight;
        if (window.MathJax?.typesetPromise) {
            MathJax.typesetPromise().catch(err => console.warn("MathJax typeset failed", err));
        }
    }

    fileAttach.addEventListener('click', () => {
        fileInput.click();
    });


    const copyMessage = (el) => {
    // Copy whole message
    const messageCopyBtn = el.querySelector('.message-copy');
    if (messageCopyBtn) {
        messageCopyBtn.onclick = async () => {
            const textToCopy = el.querySelector('p')?.innerText || '';
            if (textToCopy) {
                try {
                    await navigator.clipboard.writeText(textToCopy.trim());
                    messageCopyBtn.innerHTML = '<i class="fa-solid fa-check"></i>';
                    setTimeout(() => {
                        messageCopyBtn.innerHTML = '<i class="fa-solid fa-copy"></i>';
                    }, 1200);
                } catch (err) {
                    console.warn("Clipboard failed", err);
                }
            }
        };
    }

    // Copy from code box
    const codeCopyBtns = el.querySelectorAll('.copy-code-btn');
    codeCopyBtns.forEach(button => {
        button.onclick = async () => {
            const codeEl = button.closest('.code-header')?.nextElementSibling;
            if (codeEl) {
                try {
                    await navigator.clipboard.writeText(codeEl.innerText.trim());
                    button.textContent = "Copied!";
                    setTimeout(() => {
                        button.textContent = "Copy";
                    }, 1200);
                } catch (err) {
                    console.warn("Code copy failed", err);
                }
            }
        };
    });
};

    new MutationObserver((mutationsList) => {
        mutationsList.forEach(mutation => {
            mutation.addedNodes.forEach(node => {
                if (node.nodeType === 1) {
                    if (node.classList.contains('message')) {
                        copyMessage(node);
                    }
                }
            });
        });
    }).observe(document.body, { childList: true, subtree: true });

});