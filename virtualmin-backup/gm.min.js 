// Wrap all initialization and event listener code inside DOMContentLoaded
document.addEventListener('DOMContentLoaded', function () {

    // Defensive checks for screen elements
    const screens = {
        language: document.getElementById('mcqblust-screen-language'),
        mode: document.getElementById('mcqblust-screen-mode'),
        singleSetup: document.getElementById('mcqblust-screen-single-setup'),
        loading: document.getElementById('mcqblust-screen-loading'),
        game: document.getElementById('mcqblust-screen-game'),
        results: document.getElementById('mcqblust-screen-results'),
    };

    let gameState = {};
    let currentGameId = null;
    let timerInterval = null;

    const showScreen = (screenName) => {
        Object.values(screens).forEach(screen => { if (screen) screen.classList.add('hidden'); });
        if (screens[screenName]) screens[screenName].classList.remove('hidden');
    };

    const resetGameState = () => {
        gameState = { language: '', mode: '', settings: {}, questions: [], userAnswers: [], currentQuestionIndex: 0, score: 0 };
        currentGameId = null;
        clearInterval(timerInterval);
    };

    const populateGrades = () => {
        [document.getElementById('mcqblust-single-grade'), document.getElementById('mcqblust-multi-grade')].forEach(select => {
            if (select) for (let i = 1; i <= 13; i++) select.add(new Option(`Grade ${i}`, i));
        });
    };
    populateGrades();

    const openLightbox = () => {
        const lightbox = document.getElementById('mcqblust-lightbox');
        const container = document.getElementById('mcqblust-container');
        if (lightbox && container) {
            lightbox.classList.remove('hidden');
            container.style.opacity = '1';
            container.style.transform = 'scale(1)';
        }
    };

    const closeLightbox = () => {
        // Only prevent closing if game screen is visible (single-player)
        if (screens.game && !screens.game.classList.contains('hidden')) {
            return; // don't close during game
        }

        const lightbox = document.getElementById('mcqblust-lightbox');
        const container = document.getElementById('mcqblust-container');
        if (container && lightbox) {
            container.style.opacity = '0';
            container.style.transform = 'scale(0.95)';
            setTimeout(() => {
                lightbox.classList.add('hidden');
                window.history.pushState({}, document.title, window.location.pathname);
            }, 300);
        }
    };

    const icon = document.getElementById('mcqblust-gameyard-icon');
    if (icon) {
        icon.addEventListener('click', () => {
            resetGameState();
            openLightbox();
            showScreen('language');
        });
    }

    // Setup close button logic safely after DOM is ready
    const closeBtn = document.getElementById('mcqblust-close-btn');
    if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            closeLightbox();
        });
    } else {
        console.warn("Close button not found: #mcqblust-close-btn");
    }

    document.querySelectorAll('.mcqblust-lang-btn').forEach(btn => btn.addEventListener('click', function () {
        gameState.language = btn.dataset.lang;
        showScreen('mode');
    }));

    document.querySelectorAll('.mcqblust-back-btn').forEach(btn => btn.addEventListener('click', (e) => showScreen(e.currentTarget.dataset.target)));

    const btnSingle = document.getElementById('mcqblust-btn-single-player');
    if (btnSingle) btnSingle.addEventListener('click', () => showScreen('singleSetup'));

    // Safely add event listener for back-to-main button
    const backToMainBtn = document.getElementById('mcqblust-btn-back-to-main');
    if (backToMainBtn) {
        backToMainBtn.addEventListener('click', closeLightbox);
    } else {
        console.warn("Back to main button not found: #mcqblust-btn-back-to-main");
    }

    ['single'].forEach(prefix => {
        const mcqs = document.getElementById(`mcqblust-${prefix}-mcqs`);
        const label = document.getElementById(`mcqblust-${prefix}-mcq-count-label`);
        if (mcqs && label) {
            mcqs.addEventListener('input', (e) => {
                label.textContent = e.target.value;
            });
        }
    });

    const formSingle = document.getElementById('mcqblust-form-single-player');
    if (formSingle) formSingle.addEventListener('submit', async (e) => {
        e.preventDefault();
        gameState.mode = 'single';
        gameState.settings = {
            subject: document.getElementById('mcqblust-single-subject').value,
            grade: document.getElementById('mcqblust-single-grade').value,
            term: document.getElementById('mcqblust-single-term').value,
            timer: document.getElementById('mcqblust-single-timer').value,
            focus: document.getElementById('mcqblust-single-focus').value,
            mcqs: document.getElementById('mcqblust-single-mcqs').value,
        };
        // Safeguard: Ensure language is set
        if (!gameState.language) {
            const selectedLang = document.querySelector('.mcqblust-lang-btn.selected');
            gameState.language = selectedLang ? selectedLang.dataset.lang : 'en';
        }
        showScreen('loading');
        await generateQuestions();
        if (gameState.questions && gameState.questions.length > 0) startGame();
        else { alert("Failed to generate questions. Please try again."); showScreen('singleSetup'); }
    });


        // Generate questions via PHP endpoint, with safer parsing and debugging logic
        async function generateQuestions() {
            const { language, settings } = gameState;
            const { subject, grade, term, focus, mcqs } = settings;
            let gameId = null;
            try {
                // 1. Request question generation
                const resp = await fetch('https://apilageai.lk/generate_questions.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        language: language,
                        subject: subject,
                        grade: grade,
                        term: term,
                        focus: focus,
                        mcqs: mcqs
                    })
                });
                // Read as text first
                const respText = await resp.text();
                if (!respText || respText.trim() === "") {
                    console.error("generate_questions.php returned empty response");
                    alert("Failed to generate questions (empty response). Please try again.");
                    gameState.questions = [];
                    return;
                }
                let genResult;
                try {
                    genResult = JSON.parse(respText);
                } catch (parseErr) {
                    console.error("Non-JSON response from generate_questions.php:", respText);
                    alert("Failed to generate questions (invalid server response). Please try again.");
                    gameState.questions = [];
                    return;
                }
                if (!genResult.success || !genResult.game_id) {
                    console.error("generate_questions.php returned error or missing game_id:", genResult);
                    alert("Failed to generate questions. Please try again.");
                    gameState.questions = [];
                    return;
                }
                gameId = genResult.game_id;
                currentGameId = gameId;
                // 2. Fetch generated questions
                const qResp = await fetch(`https://apilageai.lk/get_questions.php?game_id=${encodeURIComponent(gameId)}`);
                const qRespText = await qResp.text();
                if (!qRespText || qRespText.trim() === "") {
                    console.error("get_questions.php returned empty response");
                    alert("Failed to fetch generated questions (empty response). Please try again.");
                    gameState.questions = [];
                    return;
                }
                let qData;
                try {
                    qData = JSON.parse(qRespText);
                } catch (qParseErr) {
                    console.error("Non-JSON response from get_questions.php:", qRespText);
                    alert("Failed to fetch generated questions (invalid server response). Please try again.");
                    gameState.questions = [];
                    return;
                }
                if (!qData.success || !Array.isArray(qData.questions)) {
                    console.error("get_questions.php returned error or missing questions:", qData);
                    alert("Failed to fetch generated questions. Please try again.");
                    gameState.questions = [];
                    return;
                }
                // Each question should include: question, options, answer, explanation, mark (1-5)
                gameState.questions = qData.questions;
            } catch (err) {
                console.error("Question Generation Error:", err);
                alert("Failed to generate questions due to a network or server error. Please try again.");
                gameState.questions = [];
            }
        }

        function startGame() {
            gameState.currentQuestionIndex = 0;
            gameState.userAnswers = new Array(gameState.questions.length).fill(null);
            showScreen('game');
            renderQuestion();
            if (gameState.mode === 'single' && gameState.settings.timer > 0) startTimer(gameState.settings.timer * 60);
        }
        
        function renderQuestion() {
            const q = gameState.questions[gameState.currentQuestionIndex];
            if (!q) return;
            document.getElementById('mcqblust-current-q-num').textContent = gameState.currentQuestionIndex + 1;
            document.getElementById('mcqblust-total-q-num').textContent = gameState.questions.length;
            document.getElementById('mcqblust-question-text').textContent = q.question;
            const optsContainer = document.getElementById('mcqblust-options-container');
            optsContainer.innerHTML = '';
            q.options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = option;
                if (gameState.userAnswers[gameState.currentQuestionIndex] === option) btn.classList.add('selected');
                btn.addEventListener('click', () => selectAnswer(option, btn));
                optsContainer.appendChild(btn);
            });
            updateNavButtons();
        }

        function selectAnswer(option, btnEl) {
            gameState.userAnswers[gameState.currentQuestionIndex] = option;
            document.querySelectorAll('.option-btn').forEach(btn => btn.classList.remove('selected'));
            btnEl.classList.add('selected');
            // Multiplayer: Optionally sync answer (not needed for PHP backend, but could POST partial answers)
        }
        
        const navigateQuestion = (direction) => {
            const newIndex = gameState.currentQuestionIndex + direction;
            if (newIndex >= 0 && newIndex < gameState.questions.length) {
                gameState.currentQuestionIndex = newIndex;
                renderQuestion();
            }
        };

        // Navigation buttons
        const btnNext = document.getElementById('mcqblust-btn-next');
        const btnPrev = document.getElementById('mcqblust-btn-prev');
        const btnSkip = document.getElementById('mcqblust-btn-skip');
        const btnSubmit = document.getElementById('mcqblust-btn-submit');

        function updateNavButtons() {
            if (!btnNext || !btnPrev || !btnSubmit) return;
            btnPrev.disabled = gameState.currentQuestionIndex === 0;
            if (gameState.currentQuestionIndex === gameState.questions.length - 1) {
                btnNext.classList.add('hidden');
                btnSubmit.classList.remove('hidden');
            } else {
                btnNext.classList.remove('hidden');
                btnSubmit.classList.add('hidden');
            }
        }

        if (btnNext) {
            btnNext.addEventListener('click', () => {
                navigateQuestion(1);
                updateNavButtons();
            });
        }

        if (btnPrev) {
            btnPrev.addEventListener('click', () => {
                navigateQuestion(-1);
                updateNavButtons();
            });
        }

        if (btnSkip) {
            btnSkip.addEventListener('click', () => {
                navigateQuestion(1);
                updateNavButtons();
            });
        }

        if (btnSubmit) {
            btnSubmit.addEventListener('click', async () => {
                await showResults();
            });
        }
        
        function startTimer(duration) {
            let timer = duration;
            const timerEl = document.getElementById('mcqblust-game-timer');
            timerEl.style.display = 'block';
            timerInterval = setInterval(() => {
                const minutes = Math.floor(timer / 60);
                let seconds = timer % 60;
                timerEl.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                if (--timer < 0) {
                    clearInterval(timerInterval);
                    timerEl.textContent = "Time's Up!";
                    // No more auto-submit since submit button reference is removed
                }
            }, 1000);
        }

        // Calculate score using mark for each question: add mark if correct, subtract mark if wrong
        function calculateResults(questions, answers) {
            let score = 0;
            if (!answers || !Array.isArray(answers)) return 0;
            questions.forEach((q, i) => {
                const mark = typeof q.mark === 'number' ? q.mark : 1;
                if (answers[i] === q.answer) score += mark;
                else if (answers[i] && answers[i] !== q.answer) score -= mark;
                // No penalty for blank/skipped.
            });
            return score;
        }

        function renderResultsSummary(questions, userAnswers) {
            let summaryHtml = '<div class="space-y-4">';
            questions.forEach((q, i) => {
                const userAnswer = userAnswers[i];
                const isCorrect = userAnswer === q.answer;
                const cardClass = isCorrect ? 'result-card-correct' : 'result-card-incorrect';
                const optsHtml = q.options.map(opt => {
                    let optClass = '';
                    if (opt === q.answer) optClass = 'result-option-correct';
                    else if (opt === userAnswer && !isCorrect) optClass = 'result-option-incorrect';
                    return `<div class="result-option ${optClass}">${opt}</div>`;
                }).join('');
                summaryHtml += `
                    <div class="result-card ${cardClass}">
                        <p style="font-weight: 600; margin-bottom: 0.5rem;">${i + 1}. ${q.question}</p>
                        <div style="font-size: 0.875rem;">${optsHtml}</div>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem;">Correct answer: <span style="font-weight: 600;">${q.answer}</span></p>
                        <p class="explanation"><strong>Explanation:</strong> ${q.explanation}</p>
                        <p style="font-size: 0.85rem; margin-top:0.25rem;">Mark: ${q.mark || 1}</p>
                    </div>
                `;
            });
            summaryHtml += '</div>';
            return summaryHtml;
        }

        // Submit answers to PHP endpoint and fetch results (single-player)
        async function showResults() {
            let score = 0;
            let resultSummaryHtml = '';
            try {
                // Submit answers
                const resp = await fetch('https://apilageai.lk/submit_answer.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        game_id: currentGameId,
                        answers: gameState.userAnswers
                    })
                });
                const submitResult = await resp.json();
                if (!submitResult.success) throw new Error('Failed to submit answers');
                // Fetch results
                const resResp = await fetch(`https://apilageai.lk/get_results.php?game_id=${encodeURIComponent(currentGameId)}`);
                const resData = await resResp.json();
                if (!resData.success) throw new Error('Failed to fetch results');
                score = resData.score;
            } catch (err) {
                // Fallback: calculate locally
                score = calculateResults(gameState.questions, gameState.userAnswers);
            }
            document.getElementById('mcqblust-final-score').textContent = score;
            // Calculate max possible score
            const totalMarks = gameState.questions.reduce((sum, q) => sum + (typeof q.mark === 'number' ? q.mark : 1), 0);
            document.getElementById('mcqblust-total-score').textContent = totalMarks;
            document.getElementById('mcqblust-results-summary').innerHTML = renderResultsSummary(gameState.questions, gameState.userAnswers);
            showScreen('results');
        }

        // Play Again button functionality
        const playAgainBtn = document.getElementById('mcqblust-btn-play-again');
        if (playAgainBtn) {
            playAgainBtn.addEventListener('click', () => {
                resetGameState();
                showScreen('language');
            });
        } else {
            console.warn("Play Again button not found: #mcqblust-btn-play-again");
        }

        
});


